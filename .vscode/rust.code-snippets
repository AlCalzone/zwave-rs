{
    "Nom Parser": {
        "scope": "rust",
        "prefix": "parse",
        "body": [
            "pub fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "    context(",
            "        \"${1:StructName}\",",
            "        ${0:take(1 as usize)},",
            "    )(i)",
            "}"
        ]
    },
    "impl TryFrom (Parser)": {
        "scope": "rust",
        "prefix": "impltryfrom",
        "body": [
            "impl TryFrom<&[u8]> for ${1:StructName} {",
            "    type Error = EncodingError;",
            "",
            "    fn try_from(value: &[u8]) -> crate::error::Result<Self> {",
            "        Self::parse(value).into_result()",
            "    }",
            "}"
        ]
    },
    "impl Serialize": {
        "scope": "rust",
        "prefix": "implserialize",
        "body": [
            "pub fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "    use cf::{bytes::be_u8, sequence::tuple};",
            "",
            "    ${0:tuple((be_u8(1), be_u8(2)))}",
            "}"
        ]
    },
    "impl TryInto (Serializer)": {
        "scope": "rust",
        "prefix": "impltryinto",
        "body": [
            "impl TryInto<Vec<u8>> for &${0:StructName} {",
            "    type Error = EncodingError;",
            "",
            "    fn try_into(self) -> Result<Vec<u8>, Self::Error> {",
            "        cf::gen_simple(self.serialize(), Vec::new()).into_result()",
            "    }",
            "}"
        ]
    },
    "Serial API command (no response, no callback)": {
        "scope": "rust",
        "prefix": "cmdnoresp",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty};",
            "use derive_builder::Builder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(Builder)]",
            "// #[builder(pattern = \"owned\")]",
            "// #[builder(build_fn(error = \"crate::error::Error\"))]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {}",
            "",
            "impl ${1}Request {",
            "    // Uncomment this to enable the builder pattern",
            "    // pub fn builder() -> ${1}Builder {",
            "    //     ${1}Builder::default()",
            "    // }",
            "}",
            "",
            "impl CommandBase for ${1}Request {}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        false",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        false",
            "    }",
            "}",
            "",
            "impl Parsable for ${1}Request {",
            "    fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "        // No payload",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl Serializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Request::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with response)": {
        "scope": "rust",
        "prefix": "cmdresp",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty};",
            "use derive_builder::Builder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(Builder)]",
            "// #[builder(pattern = \"owned\")]",
            "// #[builder(build_fn(error = \"crate::error::Error\"))]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {}",
            "",
            "impl ${1}Request {",
            "    // Uncomment this to enable the builder pattern",
            "    // pub fn builder() -> ${1}Builder {",
            "    //     ${1}Builder::default()",
            "    // }",
            "}",
            "",
            "impl CommandBase for ${1}Request {}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        false",
            "    }",
            "}",
            "",
            "impl Parsable for ${1}Request {",
            "    fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "        // No payload",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl Serializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Response {}",
            "",
            "impl CommandBase for ${1}Response {}",
            "",
            "impl Parsable for ${1}Response {",
            "    fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "        eprintln!(\"ERROR: ${1}Response::parse() not implemented\");",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl Serializable for ${1}Response {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Response::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with callback)": {
        "scope": "rust",
        "prefix": "cmdcb",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty};",
            "use derive_builder::Builder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(Builder)]",
            "// #[builder(pattern = \"owned\")]",
            "// #[builder(build_fn(error = \"crate::error::Error\"))]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {",
            "    // #[builder(setter(skip))]",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl ${1}Request {",
            "    // Uncomment this to enable the builder pattern",
            "    // pub fn builder() -> ${1}Builder {",
            "    //     ${1}Builder::default()",
            "    // }",
            "}",
            "",
            "impl CommandBase for ${1}Request {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        false",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn needs_callback_id(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn set_callback_id(&mut self, callback_id: Option<u8>) {",
            "        self.callback_id = callback_id;",
            "    }",
            "}",
            "",
            "impl Parsable for ${1}Request {",
            "    fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "        // No payload",
            "        Ok((i, Self {",
            "            callback_id: None,",
            "        }))",
            "    }",
            "}",
            "",
            "impl Serializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Callback {",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandBase for ${1}Callback {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl Parsable for ${1}Callback {",
            "    fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "        eprintln!(\"ERROR: ${1}Callback::parse() not implemented\");",
            "        Ok((i, Self {",
            "            callback_id: None,",
            "        }))",
            "    }",
            "}",
            "",
            "impl Serializable for ${1}Callback {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Callback::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with response & callback)": {
        "scope": "rust",
        "prefix": "cmdrescb",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty};",
            "use derive_builder::Builder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(Builder)]",
            "// #[builder(pattern = \"owned\")]",
            "// #[builder(build_fn(error = \"crate::error::Error\"))]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {",
            "    // #[builder(setter(skip))]",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl ${1}Request {",
            "    // Uncomment this to enable the builder pattern",
            "    // pub fn builder() -> ${1}Builder {",
            "    //     ${1}Builder::default()",
            "    // }",
            "}",
            "",
            "impl CommandBase for ${1}Request {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn needs_callback_id(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn set_callback_id(&mut self, callback_id: Option<u8>) {",
            "        self.callback_id = callback_id;",
            "    }",
            "}",
            "",
            "impl Parsable for ${1}Request {",
            "    fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "        // No payload",
            "        Ok((i, Self {",
            "            callback_id: None,",
            "        }))",
            "    }",
            "}",
            "",
            "impl Serializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Response {}",
            "",
            "impl CommandBase for ${1}Response {}",
            "",
            "impl Parsable for ${1}Response {",
            "    fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "        eprintln!(\"ERROR: ${1}Response::parse() not implemented\");",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl Serializable for ${1}Response {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Response::serialize() not implemented\")",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Callback {",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandBase for ${1}Callback {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl Parsable for ${1}Callback {",
            "    fn parse(i: encoding::Input) -> encoding::ParseResult<Self> {",
            "        eprintln!(\"ERROR: ${1}Callback::parse() not implemented\");",
            "        Ok((i, Self {",
            "            callback_id: None,",
            "        }))",
            "    }",
            "}",
            "",
            "impl Serializable for ${1}Callback {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Callback::serialize() not implemented\")",
            "    }",
            "}"
        ]
    }
}
