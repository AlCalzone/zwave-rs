{
  "Nom Parser": {
    "scope": "rust",
    "prefix": "parse",
    "body": [
      "pub fn parse(i: parse::Input) -> parse::Result<Self> {",
      "    context(",
      "        \"${1:StructName}\",",
      "        ${0:take(1 as usize)},",
      "    )(i)",
      "}"
    ]
  },
  "impl TryFrom (Parser)": {
    "scope": "rust",
    "prefix": "impltryfrom",
    "body": [
      "impl TryFrom<&[u8]> for ${1:StructName} {",
      "    type Error = crate::error::Error;",
      "",
      "    fn try_from(value: &[u8]) -> crate::error::Result<Self> {",
      "        Self::parse(value).into_result()",
      "    }",
      "}"
    ]
  },
  "impl Serialize": {
    "scope": "rust",
    "prefix": "implserialize",
    "body": [
      "pub fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
      "    use cf::{bytes::be_u8, sequence::tuple};",
      "",
      "    ${0:tuple((be_u8(1), be_u8(2)))}",
      "}"
    ]
  },
  "impl TryInto (Serializer)": {
    "scope": "rust",
    "prefix": "impltryinto",
    "body": [
      "impl TryInto<Vec<u8>> for &${0:StructName} {",
      "    type Error = crate::error::Error;",
      "",
      "    fn try_into(self) -> Result<Vec<u8>, Self::Error> {",
      "        cf::gen_simple(self.serialize(), Vec::new()).into_result()",
      "    }",
      "}"
    ]
  },
  "Serial API command (no response, no callback)": {
    "scope": "rust",
    "prefix": "cmdnoresp",
    "body": [
      "use crate::{parse::empty, prelude::*};",
      "",
      "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {}",
      "",
      "impl ${1}Request {",
      "    pub fn new() -> Self {",
      "        Self {}",
      "    }",
      "}",
      "",
      "impl Parsable for ${1}Request {",
      "    fn parse(i: parse::Input) -> parse::Result<Self> {",
      "        // No payload",
      "        Ok((i, Self {}))",
      "    }",
      "}",
      "",
      "impl Serializable for ${1}Request {",
      "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
      "        // No payload",
      "        empty()",
      "    }",
      "}",
      "",
      "impl CommandRequest for ${1}Request {",
      "    fn expects_response(&self) -> bool {",
      "        false",
      "    }",
      "",
      "    fn test_response(&self, response: &Command) -> bool {",
      "        false",
      "    }",
      "",
      "    fn expects_callback(&self) -> bool {",
      "        false",
      "    }",
      "",
      "    fn test_callback(&self, _callback: &Command) -> bool {",
      "        false",
      "    }",
      "",
      "    fn callback_id(&self) -> Option<u8> {",
      "        return None;",
      "    }",
      "",
      "    fn set_callback_id(&mut self, _callback_id: Option<u8>) {",
      "        // No callback",
      "    }",
      "}"
    ]
  },
  "Serial API command (with response)": {
    "scope": "rust",
    "prefix": "cmdresp",
    "body": [
      "use crate::{parse::empty, prelude::*};",
      "",
      "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {}",
      "",
      "impl ${1}Request {",
      "    pub fn new() -> Self {",
      "        Self {}",
      "    }",
      "}",
      "",
      "impl Parsable for ${1}Request {",
      "    fn parse(i: parse::Input) -> parse::Result<Self> {",
      "        // No payload",
      "        Ok((i, Self {}))",
      "    }",
      "}",
      "",
      "impl Serializable for ${1}Request {",
      "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
      "        // No payload",
      "        empty()",
      "    }",
      "}",
      "",
      "impl CommandRequest for ${1}Request {",
      "    fn expects_response(&self) -> bool {",
      "        true",
      "    }",
      "",
      "    fn test_response(&self, response: &Command) -> bool {",
      "        response.command_type() == CommandType::Response",
      "            && response.function_type() == self.function_type()",
      "    }",
      "",
      "    fn expects_callback(&self) -> bool {",
      "        false",
      "    }",
      "",
      "    fn test_callback(&self, _callback: &Command) -> bool {",
      "        false",
      "    }",
      "",
      "    fn callback_id(&self) -> Option<u8> {",
      "        return None;",
      "    }",
      "",
      "    fn set_callback_id(&mut self, _callback_id: Option<u8>) {",
      "        // No callback",
      "    }",
      "}",
      "",
      "pub struct ${1}Response {}",
      "",
      "impl Parsable for ${1}Response {",
      "    fn parse(i: parse::Input) -> parse::Result<Self> {",
      "        todo!()",
      "    }",
      "}",
      "",
      "impl Serializable for ${1}Response {",
      "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
      "        move |out| todo!()",
      "    }",
      "}"
    ]
  }
}
