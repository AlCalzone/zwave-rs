{
    "Nom Parser": {
        "scope": "rust",
        "prefix": "parse",
        "body": [
            "pub fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "    context(",
            "        \"${1:StructName}\",",
            "        ${0:take(1 as usize)},",
            "    )(i)",
            "}"
        ]
    },
    "impl TryFrom (Parser)": {
        "scope": "rust",
        "prefix": "impltryfrom",
        "body": [
            "impl TryFrom<&[u8]> for ${1:StructName} {",
            "    type Error = EncodingError;",
            "",
            "    fn try_from(value: &[u8]) -> crate::error::Result<Self> {",
            "        Self::parse(value).into_result()",
            "    }",
            "}"
        ]
    },
    "impl Serialize": {
        "scope": "rust",
        "prefix": "implserialize",
        "body": [
            "pub fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "    use cf::{bytes::be_u8, sequence::tuple};",
            "",
            "    ${0:tuple((be_u8(1), be_u8(2)))}",
            "}"
        ]
    },
    "impl TryInto (Serializer)": {
        "scope": "rust",
        "prefix": "impltryinto",
        "body": [
            "impl TryInto<Vec<u8>> for &${0:StructName} {",
            "    type Error = EncodingError;",
            "",
            "    fn try_into(self) -> Result<Vec<u8>, Self::Error> {",
            "        cf::gen_simple(self.serialize(), Vec::new()).into_result()",
            "    }",
            "}"
        ]
    },
    "Serial API command (no response, no callback)": {
        "scope": "rust",
        "prefix": "cmdnoresp",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use typed_builder::TypedBuilder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {}",
            "",
            "impl CommandId for ${1}Request {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Host",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Request {}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        false",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        false",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Request {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        // No payload",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Request::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with response)": {
        "scope": "rust",
        "prefix": "cmdresp",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use typed_builder::TypedBuilder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {}",
            "",
            "impl CommandId for ${1}Request {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Host",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Request {}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        false",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Request {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        // No payload",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Response {}",
            "",
            "impl CommandId for ${1}Response {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Response",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Response {}",
            "",
            "impl CommandParsable for ${1}Response {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i, \"ERROR: ${1}Response::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Response {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Response::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with callback)": {
        "scope": "rust",
        "prefix": "cmdcb",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use typed_builder::TypedBuilder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {",
            "    // #[builder(setter(skip), default)]",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandId for ${1}Request {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Host",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Request {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        false",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn needs_callback_id(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn set_callback_id(&mut self, callback_id: Option<u8>) {",
            "        self.callback_id = callback_id;",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Request {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}Request::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Callback {",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandId for ${1}Callback {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Callback {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Callback {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i, \"ERROR: ${1}Callback::parse() not implemented\");",
            "        // Ok((i, Self {",
            "        //     callback_id: None,",
            "        // }))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Callback {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Callback::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with response & callback)": {
        "scope": "rust",
        "prefix": "cmdrescb",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use typed_builder::TypedBuilder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {",
            "    // #[builder(setter(skip), default)]",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandId for ${1}Request {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Host",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Request {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn needs_callback_id(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn set_callback_id(&mut self, callback_id: Option<u8>) {",
            "        self.callback_id = callback_id;",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Request {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}Request::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Response {}",
            "",
            "impl CommandId for ${1}Response {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Response",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Response {}",
            "",
            "impl CommandParsable for ${1}Response {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}Response::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Response {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Response::serialize() not implemented\")",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Callback {",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandId for ${1}Callback {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Callback {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Callback {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}Callback::parse() not implemented\");",
            "        // Ok((i, Self {",
            "        //     callback_id: None,",
            "        // }))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Callback {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Callback::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (unsolicited)": {
        "scope": "rust",
        "prefix": "cmduns",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, parser_not_implemented};",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}} {}",
            "",
            "impl CommandId for ${1} {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1} {}",
            "",
            "impl CommandParsable for ${1} {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "CC implementation base": {
        "scope": "rust",
        "prefix": "zwcc",
        "body": [
            "use cookie_factory as cf;",
            "use crate::prelude::*;",
            "use crate::values::*;",
            "use nom::{combinator::{map, opt}, sequence::tuple};",
            "use proc_macros::{CCValues, TryFromRepr};",
            "use typed_builder::TypedBuilder;",
            "use zwave_core::cache::CacheValue;",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use zwave_core::prelude::*;",
            "use zwave_core::value_id::{ValueId, ValueIdProperties};",
            "",
            "enum ${1}CCProperties {",
            "    ${0:CurrentValue} = 0x00,",
            "}",
            "",
            "// TODO: If this CC uses dynamic values, consider implementing the unsafe trait",
            "// ToDiscriminant for easier conversion of the static properties"
            "// Note that this requires #[repr(...)] on the enum definition.",
            "impl From<${1}CCProperties> for (u32, Option<u32>) {",
            "    fn from(val: ${1}CCProperties) -> Self {",
            "        (val as u32, None)",
            "    }",
            "}",
            "",
            "pub struct ${1}CCValues;",
            "impl ${1}CCValues {",
            "    cc_value_static_property!(",
            "        ${1}",
            "        ${0}",
            "        ValueMetadata::Numeric(ValueMetadataNumeric::default()),",
            "        CCValueOptions::default()"
            "    )",
            "},"
            "",
            "#[derive(Debug, Clone, Copy, PartialEq, TryFromRepr)]",
            "#[repr(u8)]",
            "pub enum ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CCCommand {",
            "    ${2:Set} = ${3:0x01},",
            "    ${4:Get} = ${5:0x02},",
            "    ${6:Report} = ${7:0x03},",
            "}",
            ""
        ]
    },
    "CC value definitions (only static)": {
        "scope": "rust",
        "prefix": "zwccvalstat",
        "body": [
            "#[derive(Debug, Clone, Copy, PartialEq, TryFromRepr)]",
            "#[repr(${2:u8})]",
            "enum ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CCProperties {",
            "    ${3:CurrentValue} = 0x00,",
            "}",
            "",
            "impl From<${1}CCProperties> for ValueIdProperties {",
            "    fn from(val: ${1}CCProperties) -> Self {",
            "        Self::new(val as u32, None)",
            "    }",
            "}",
            "",
            "impl TryFrom<ValueIdProperties> for ${1}CCProperties {",
            "    type Error = ();",
            "",
            "    fn try_from(val: ValueIdProperties) -> Result<Self, Self::Error> {",
            "        match (Self::try_from(val.property() as ${2}), val.property_key()) {",
            "            (Ok(prop), None) => Ok(prop),",
            "            _ => Err(()),",
            "        }",
            "    }",
            "}",
            "",
            "pub struct ${1}CCValues;",
            "impl ${1}CCValues {",
            "    cc_value_static_property!(",
            "        ${1},",
            "        ${3},",
            "        ValueMetadata::Numeric(ValueMetadataNumeric::default()),",
            "        CCValueOptions::default()"
            "    );",
            "}"
        ]
    },
    "CC value definitions (static and dynamic)": {
        "scope": "rust",
        "prefix": "zwccvaldyn",
        "body": [
            "#[derive(Debug, Clone, Copy, PartialEq, TryFromRepr)]",
            "#[repr(${2:u8})] // must match the ToDiscriminant impl",
            "enum ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CCProperties {",
            "    ${3:StaticProp} = 0x00,",
            "    ${4:DynamicProp}(${5:u8}) = 0x01,"
            "}",
            "",
            "unsafe impl ToDiscriminant<${2}> for ${1}CCProperties {}",
            "",
            "impl From<${1}CCProperties> for ValueIdProperties {",
            "    fn from(val: ${1}CCProperties) -> Self {",
            "        match val {",
            "            ${1}CCProperties::${4}(${6:arg}) => {",
            "                Self::new(val.to_discriminant(), Some(${6} as u32))",
            "            }",
            "            _ => Self::new(val.to_discriminant(), None),",
            "        }",
            "    }",
            "}",
            "",
            "impl TryFrom<ValueIdProperties> for ${1}CCProperties {",
            "    type Error = ();",
            "",
            "    fn try_from(val: ValueIdProperties) -> Result<Self, Self::Error> {",
            "        match (",
            "            Self::try_from(value.property() as ${2}),",
            "            value.property_key(),",
            "        ) {",
            "            // Static properties have no property key",
            "            (Ok(prop), None) => return Ok(prop),",
            "            // Dynamic properties have one",
            "            (Err(TryFromReprError::NonPrimitive(d)), Some(k)) => {",
            "                // Figure out which one it is",
            "                let ${4:/snake_case}_discr = Self::${4}(0).to_discriminant();",
            "                if d == ${4:/snake_case}_discr && k <= ${5}::MAX as u32 {",
            "                    return Ok(Self::${4}(k as ${5}));",
            "                }",
            "            }",
            "            _ => (),",
            "        }",
            "",
            "        Err(())",
            "    }",
            "}",
            "",
            "pub struct ${1}CCValues;",
            "impl ${1}CCValues {",
            "    cc_value_static_property!(",
            "        ${1},",
            "        ${3},",
            "        ValueMetadata::Numeric(ValueMetadataNumeric::default()),",
            "        CCValueOptions::default()"
            "    );",
            "",
            "    cc_value_dynamic_property!(",
            "        ${1},",
            "        ${4},",
            "        |${6}: ${5}| ValueMetadata::Numeric(ValueMetadataNumeric::default()),",
            "        CCValueOptions::default()"
            "    );",
            "}"
        ]
    },
    "CC implementation (request, no response)": {
        "scope": "rust",
        "prefix": "zwccreqnoresp",
        "body": [
            "#[derive(Debug, Clone, PartialEq, TypedBuilder, CCValues)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CC${2:Set} {",
            "    ${0}",
            "}",
            "",
            "impl CCBase for ${1}CC${2} {}",
            "",
            "impl CCId for ${1}CC${2} {",
            "    fn cc_id(&self) -> CommandClasses {",
            "        CommandClasses::${1}",
            "    }",
            "",
            "    fn cc_command(&self) -> Option<u8> {",
            "        Some(${1}CCCommand::${2} as _)",
            "    }",
            "}",
            "",
            "impl CCRequest for ${1}CC${2} {",
            "    fn expects_response(&self) -> bool {",
            "        false",
            "    }",
            "",
            "    fn test_response(&self, _response: &CC) -> bool {",
            "        false",
            "    }",
            "}",
            "",
            "impl CCParsable for ${1}CC${2} {",
            "    fn parse<'a>(i: encoding::Input<'a>, _ctx: &CCParsingContext) -> ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}CC${2}::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CCSerializable for ${1}CC${2} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cf::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}CC${2}::serialize() not implemented\")",
            "    }",
            "}",
            ""
        ]
    },
    "CC implementation (get request, with response)": {
        "scope": "rust",
        "prefix": "zwccget",
        "body": [
            "#[derive(Debug, Clone, PartialEq, TypedBuilder, CCValues)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CC${2:Get} {",
            "    ${0}",
            "}",
            "",
            "impl CCBase for ${1}CC${2} {}",
            "",
            "impl CCId for ${1}CC${2} {",
            "    fn cc_id(&self) -> CommandClasses {",
            "        CommandClasses::${1}",
            "    }",
            "",
            "    fn cc_command(&self) -> Option<u8> {",
            "        Some(${1}CCCommand::${2} as _)",
            "    }",
            "}",
            "",
            "impl CCRequest for ${1}CC${2} {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn test_response(&self, _response: &CC) -> bool {",
            "        matches!(response, CC::${1}CC${3:Report}(_))",
            "    }",
            "}",
            "",
            "impl CCParsable for ${1}CC${2} {",
            "    fn parse<'a>(i: encoding::Input<'a>, _ctx: &CCParsingContext) -> ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}CC${2}::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CCSerializable for ${1}CC${2} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cf::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}CC${2}::serialize() not implemented\")",
            "    }",
            "}",
            ""
        ]
    },
    "CC implementation (empty get request)": {
        "scope": "rust",
        "prefix": "zwccemptyget",
        "body": [
            "#[derive(Default, Debug, Clone, PartialEq, CCValues)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CC${2:Get} {}",
            "",
            "impl CCBase for ${1}CC${2} {}",
            "",
            "impl CCId for ${1}CC${2} {",
            "    fn cc_id(&self) -> CommandClasses {",
            "        CommandClasses::${1}",
            "    }",
            "",
            "    fn cc_command(&self) -> Option<u8> {",
            "        Some(${1}CCCommand::${2} as _)",
            "    }",
            "}",
            "",
            "impl CCRequest for ${1}CC${2} {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn test_response(&self, response: &CC) -> bool {",
            "        matches!(response, CC::${1}CC${3:Report}(_))",
            "    }",
            "}",
            "",
            "impl CCParsable for ${1}CC${2} {",
            "    fn parse<'a>(i: encoding::Input<'a>, _ctx: &CCParsingContext) -> ParseResult<'a, Self> {",
            "        // No payload",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CCSerializable for ${1}CC${2} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cf::SerializeFn<W> + 'a {",
            "        empty()",
            "    }",
            "}",
            ""
        ]
    },
    "CC implementation (report)": {
        "scope": "rust",
        "prefix": "zwccreport",
        "body": [
            "#[derive(Debug, Clone, PartialEq, TypedBuilder, CCValues)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CC${2:Report} {",
            "    #[cc_values(${1}CC::${0})]",
            "    ${0}",
            "}",
            "",
            "impl CCBase for ${1}CC${2} {}",
            "",
            "impl CCId for ${1}CC${2} {",
            "    fn cc_id(&self) -> CommandClasses {",
            "        CommandClasses::${1}",
            "    }",
            "",
            "    fn cc_command(&self) -> Option<u8> {",
            "        Some(${1}CCCommand::${2} as _)",
            "    }",
            "}",
            "",
            "impl CCParsable for ${1}CC${2} {",
            "    fn parse<'a>(i: encoding::Input<'a>, _ctx: &CCParsingContext) -> ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}CC${2}::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CCSerializable for ${1}CC${2} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cf::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}CC${2}::serialize() not implemented\")",
            "    }",
            "}",
            ""
        ]
    },
    "CC API implementation": {
        "scope": "rust",
        "prefix": "zwccapi",
        "body": [
            "use crate::{cc_api_assert_supported, expect_cc_or_timeout, get_implemented_version};",
            "use crate::{CCAPIResult, CCInterviewContext, EndpointLike, CCAPI};",
            "use zwave_cc::commandclass::{${1:${TM_FILENAME_BASE}}::*, CCAddressable};",
            "use zwave_core::{cache::CacheExt, prelude::*};",
            "",
            "pub struct ${2:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CCAPI<'a> {",
            "    endpoint: &'a dyn EndpointLike<'a>,",
            "}",
            "",
            "impl<'a> CCAPI<'a> for ${2}CCAPI<'a> {",
            "    fn new(endpoint: &'a dyn EndpointLike<'a>) -> Self",
            "    where",
            "        Self: Sized,",
            "    {",
            "        Self { endpoint }",
            "    }",
            "",
            "    fn cc_id(&self) -> CommandClasses {",
            "        CommandClasses::${2}",
            "    }",
            "",
            "    fn cc_version(&self) -> u8 {",
            "        ${3:1}",
            "    }",
            "",
            "    fn interview_depends_on(&self) -> &'static [CommandClasses] {",
            "        // Optional: Return a list of required CCs or remove this method"
            "        &[ /* ... */]",
            "    }",
            "",
            "    async fn interview<'ctx: 'a>(&self, ctx: &CCInterviewContext<'ctx>) -> CCAPIResult<()> {",
            "        let endpoint = ctx.endpoint;",
            "        let node = endpoint.get_node();",
            "        let cache = node.value_cache();",
            "",
            "        println!(",
            "            \"Node {}, {} - Interviewing ${2} CC\",",
            "            endpoint.node_id(),",
            "            endpoint.index(),",
            "        );",
            "",
            "        Ok(())",
            "    }",
            "",
            "    async fn refresh_values(&self) -> CCAPIResult<()> {",
            "        // Nothing that requires refreshing",
            "        Ok(())",
            "    }",
            "}",
            "",
            "impl ${2}CCAPI<'_> {",
            "    pub async fn get(&self) -> CCAPIResult<Option<${2}CCReport>> {",
            "        // Optional: Test support for this command:",
            "        // cc_api_assert_supported!(self, get);",
            "        // and implement the supports_get() method using the zwccapisupp snippet",
            "",
            "        let node = self.endpoint.get_node();",
            "        let driver = node.driver();",
            "        let cc = ${2}CCGet::default().with_destination(node.id().into());",
            "        let response = driver.exec_node_command(&cc, None).await;",
            "        let response = expect_cc_or_timeout!(response, ${2}CCReport);",
            "",
            "        Ok(response)",
            "    }",
            "}",
            "",
        ]
    },
    "CC API test support": {
        "scope": "rust",
        "prefix": "zwccapisupp",
        "body": [
            "pub fn supports_${1:get}(&self) -> Option<bool> {",
            "    // Example: Test version of the CC",
            "    self.endpoint.get_cc_version(self.cc_id()).map(|v| v >= 2)",
            "    // Example: Read value from cache",
            "    // self.endpoint.value_cache().read_bool(&${2:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CCValues::supports_${1}().id)",
            "}",
            ""
        ]
    },
}
