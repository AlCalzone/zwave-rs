{
    "Nom Parser": {
        "scope": "rust",
        "prefix": "parse",
        "body": [
            "pub fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "    context(",
            "        \"${1:StructName}\",",
            "        ${0:take(1 as usize)},",
            "    )(i)",
            "}"
        ]
    },
    "impl TryFrom (Parser)": {
        "scope": "rust",
        "prefix": "impltryfrom",
        "body": [
            "impl TryFrom<&[u8]> for ${1:StructName} {",
            "    type Error = EncodingError;",
            "",
            "    fn try_from(value: &[u8]) -> crate::error::Result<Self> {",
            "        Self::parse(value).into_result()",
            "    }",
            "}"
        ]
    },
    "impl Serialize": {
        "scope": "rust",
        "prefix": "implserialize",
        "body": [
            "pub fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "    use cf::{bytes::be_u8, sequence::tuple};",
            "",
            "    ${0:tuple((be_u8(1), be_u8(2)))}",
            "}"
        ]
    },
    "impl TryInto (Serializer)": {
        "scope": "rust",
        "prefix": "impltryinto",
        "body": [
            "impl TryInto<Vec<u8>> for &${0:StructName} {",
            "    type Error = EncodingError;",
            "",
            "    fn try_into(self) -> Result<Vec<u8>, Self::Error> {",
            "        cf::gen_simple(self.serialize(), Vec::new()).into_result()",
            "    }",
            "}"
        ]
    },
    "Serial API command (no response, no callback)": {
        "scope": "rust",
        "prefix": "cmdnoresp",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use typed_builder::TypedBuilder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {}",
            "",
            "impl CommandId for ${1}Request {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Host",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Request {}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        false",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        false",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Request {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        // No payload",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Request::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with response)": {
        "scope": "rust",
        "prefix": "cmdresp",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use typed_builder::TypedBuilder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {}",
            "",
            "impl CommandId for ${1}Request {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Host",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Request {}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        false",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Request {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        // No payload",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Response {}",
            "",
            "impl CommandId for ${1}Response {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Response",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Response {}",
            "",
            "impl CommandParsable for ${1}Response {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i, \"ERROR: ${1}Response::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Response {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Response::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with callback)": {
        "scope": "rust",
        "prefix": "cmdcb",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use typed_builder::TypedBuilder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {",
            "    // #[builder(setter(skip), default)]",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandId for ${1}Request {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Host",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Request {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        false",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn needs_callback_id(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn set_callback_id(&mut self, callback_id: Option<u8>) {",
            "        self.callback_id = callback_id;",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Request {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}Request::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Callback {",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandId for ${1}Callback {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Callback {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Callback {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i, \"ERROR: ${1}Callback::parse() not implemented\");",
            "        // Ok((i, Self {",
            "        //     callback_id: None,",
            "        // }))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Callback {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Callback::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (with response & callback)": {
        "scope": "rust",
        "prefix": "cmdrescb",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "use typed_builder::TypedBuilder;",
            "",
            "#[derive(Default, Debug, Clone, PartialEq)]",
            "// Uncomment this to enable the builder pattern",
            "// #[derive(TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}Request {",
            "    // #[builder(setter(skip), default)]",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandId for ${1}Request {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Host",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Request {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandRequest for ${1}Request {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn expects_callback(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn needs_callback_id(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn set_callback_id(&mut self, callback_id: Option<u8>) {",
            "        self.callback_id = callback_id;",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Request {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}Request::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Request {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        // No payload",
            "        empty()",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Response {}",
            "",
            "impl CommandId for ${1}Response {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Response",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Response {}",
            "",
            "impl CommandParsable for ${1}Response {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}Response::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Response {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Response::serialize() not implemented\")",
            "    }",
            "}",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1}Callback {",
            "    callback_id: Option<u8>",
            "}",
            "",
            "impl CommandId for ${1}Callback {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1}Callback {",
            "    fn callback_id(&self) -> Option<u8> {",
            "        self.callback_id",
            "    }",
            "}",
            "",
            "impl CommandParsable for ${1}Callback {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}Callback::parse() not implemented\");",
            "        // Ok((i, Self {",
            "        //     callback_id: None,",
            "        // }))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1}Callback {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}Callback::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "Serial API command (unsolicited)": {
        "scope": "rust",
        "prefix": "cmduns",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use nom::{bytes::complete::tag, character::complete::none_of, combinator::map, multi::many1};",
            "use zwave_core::encoding::{self, parser_not_implemented};",
            "",
            "#[derive(Debug, Clone, PartialEq)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}} {}",
            "",
            "impl CommandId for ${1} {",
            "    fn command_type(&self) -> CommandType {",
            "        CommandType::Request",
            "    }",
            "",
            "    fn function_type(&self) -> FunctionType {",
            "        FunctionType::${1}",
            "    }",
            "",
            "    fn origin(&self) -> MessageOrigin {",
            "        MessageOrigin::Controller",
            "    }",
            "}",
            "",
            "impl CommandBase for ${1} {}",
            "",
            "impl CommandParsable for ${1} {",
            "    fn parse<'a>(i: encoding::Input<'a>, ctx: &CommandEncodingContext) -> encoding::ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CommandSerializable for ${1} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self, ctx: &'a CommandEncodingContext) -> impl cookie_factory::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}::serialize() not implemented\")",
            "    }",
            "}"
        ]
    },
    "CC implementation base": {
        "scope": "rust",
        "prefix": "zwcc",
        "body": [
            "use crate::prelude::*;",
            "use zwave_core::prelude::*;",
            "",
            "use cookie_factory as cf;",
            "use derive_try_from_primitive::TryFromPrimitive;"
            "use nom::{combinator::{map, opt}, sequence::tuple};",
            "use typed_builder::TypedBuilder;",
            "use zwave_core::encoding::{self, encoders::empty, parser_not_implemented};",
            "",
            "#[derive(Debug, Clone, Copy, PartialEq, TryFromPrimitive)]",
            "#[repr(u8)]",
            "pub enum ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CCCommand {",
            "    ${2:Set} = ${3:0x01},",
            "    ${4:Get} = ${5:0x02},",
            "    ${6:Report} = ${7:0x03},",
            "}",
            ""
        ]
    },
    "CC implementation (request, no response)": {
        "scope": "rust",
        "prefix": "zwccreqnoresp",
        "body": [
            "#[derive(Debug, Clone, PartialEq, TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CC${2:Set} {",
            "    ${0}",
            "}",
            "",
            "impl CCBase for ${1}CC${2} {}",
            "",
            "impl CCId for ${1}CC${2} {",
            "    fn cc_id(&self) -> CommandClasses {",
            "        CommandClasses::${1}",
            "    }",
            "",
            "    fn cc_command(&self) -> Option<u8> {",
            "        Some(${1}CCCommand::${2} as _)",
            "    }",
            "}",
            "",
            "impl CCRequest for ${1}CC${2} {",
            "    fn expects_response(&self) -> bool {",
            "        false",
            "    }",
            "",
            "    fn test_response(&self, _response: &CC) -> bool {",
            "        false",
            "    }",
            "}",
            "",
            "impl CCParsable for ${1}CC${2} {",
            "    fn parse<'a>(i: encoding::Input<'a>, _ctx: &CCParsingContext) -> ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}CC${2}::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CCSerializable for ${1}CC${2} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cf::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}CC${2}::serialize() not implemented\")",
            "    }",
            "}",
            ""
        ]
    },
    "CC implementation (empty get request)": {
        "scope": "rust",
        "prefix": "zwccemptyget",
        "body": [
            "#[derive(Debug, Clone, PartialEq, TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CC${2:Get} {}",
            "",
            "impl CCBase for ${1}CC${2} {}",
            "",
            "impl CCId for ${1}CC${2} {",
            "    fn cc_id(&self) -> CommandClasses {",
            "        CommandClasses::${1}",
            "    }",
            "",
            "    fn cc_command(&self) -> Option<u8> {",
            "        Some(${1}CCCommand::${2} as _)",
            "    }",
            "}",
            "",
            "impl CCRequest for ${1}CC${2} {",
            "    fn expects_response(&self) -> bool {",
            "        true",
            "    }",
            "",
            "    fn test_response(&self, response: &CC) -> bool {",
            "        matches!(response, CC::${1}CC${3:Report}(_))",
            "    }",
            "}",
            "",
            "impl CCParsable for ${1}CC${2} {",
            "    fn parse<'a>(i: encoding::Input<'a>, _ctx: &CCParsingContext) -> ParseResult<'a, Self> {",
            "        // No payload",
            "        Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CCSerializable for ${1}CC${2} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cf::SerializeFn<W> + 'a {",
            "        empty()",
            "    }",
            "}",
            ""
        ]
    },
    "CC implementation (report)": {
        "scope": "rust",
        "prefix": "zwccreport",
        "body": [
            "#[derive(Debug, Clone, PartialEq, TypedBuilder)]",
            "pub struct ${1:${TM_FILENAME_BASE/(.*)$/${1:/pascalcase}/}}CC${2:Report} {",
            "    ${0}",
            "}",
            "",
            "impl CCBase for ${1}CC${2} {}",
            "",
            "impl CCId for ${1}CC${2} {",
            "    fn cc_id(&self) -> CommandClasses {",
            "        CommandClasses::${1}",
            "    }",
            "",
            "    fn cc_command(&self) -> Option<u8> {",
            "        Some(${1}CCCommand::${2} as _)",
            "    }",
            "}",
            "",
            "impl CCParsable for ${1}CC${2} {",
            "    fn parse<'a>(i: encoding::Input<'a>, _ctx: &CCParsingContext) -> ParseResult<'a, Self> {",
            "        return parser_not_implemented(i,  \"ERROR: ${1}CC${2}::parse() not implemented\");",
            "        // Ok((i, Self {}))",
            "    }",
            "}",
            "",
            "impl CCSerializable for ${1}CC${2} {",
            "    fn serialize<'a, W: std::io::Write + 'a>(&'a self) -> impl cf::SerializeFn<W> + 'a {",
            "        use cf::{bytes::be_u8, sequence::tuple};",
            "        move |out| todo!(\"ERROR: ${1}CC${2}::serialize() not implemented\")",
            "    }",
            "}",
            ""
        ]
    },
}
